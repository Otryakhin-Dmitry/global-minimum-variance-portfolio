---
title: "An introduction to HDShOP package with examples."
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r echo = FALSE}
library(HDShOP)
```

## Overview of existing software
There exist packages implementing other shrinkage estimators for covariance matrices. ShrinkCovMat contains methods developed in Touloumis, A. (2015). CovTools provides functions based on Ledoit and Wolf (2003, 2004) as well as oracle approximating shrinkage estimator and Rao-Blackwell Ledoit-Wolf Estimator from Chen et al (2010). nlshrink provides methods from Ledoit and Wolf (2004, 2015). 

Among packages devoted to portfolio management the most developed seems to be fPortfolio by RMetrics, Wuertz et al (2014). One way in which the authors formulate the MV portfolio optimization problem is minimizing the portfolio variance 
$$
min_w w^T \hat \Sigma w
$$
while constraining the portfolio return and asset allocation.

$$
w^T \hat \mu = \bar r, \quad w^T 1 = 1
$$

To achieve this, relatively simple estimators of the asset mean return and covariance matrix are used, and then a quadratic solver performs optimization to find the portfolio weights. Numerical solvers allow for different kinds of constrains such as prohibition of short sells $w>0$ or group and box constrains. Another way included is to fix the variance and maximize the portfolio return to construct the so-called minimum risk efficient portfolio. Apart from construction, fPortfolio also provides means for backtesting and various plotting functions.


## General setting
This package is implementation of various shrinkage techniques with application to the so-called mean-variance portfolios. It contains three main functions: MVShrinkPortfolio, CovarEstim and MeanEstim. 

The following setup will be used throughout all examples:
```{r experiment setup}

n<-3e2 # number of realizations
p<-.5*n # number of assets
gamma<-1

# the target for covariance shrinkage
TM <- matrix(0, p, p) 
diag(TM) <- 1

# the target for shrinkage of the mean vector
mu_0 <- rep(0, p)
mu_0[1:10] <- 10:1

b<-rep(1/p,p)
```

All data matrices in the package are handled in a way that the variables are in rows and observations- in columns.
```{r}
set.seed(5)

# CMtrx_true <- RandCovMtrx(p=p) # Generate an arbitrary covariance matrix
# x <- t(MASS::mvrnorm(n=n , mu=rep(0,p), Sigma=CMtrx_true))
# x <- matrix(data = rnorm(n*p), nrow = p, ncol = n) # simulated asset returns
x <- t(SP_daily_asset_returns[1:n,2:(p+1)])
x <- as.matrix(x)
```


## S3 class MeanVar_portfolio
Traditional, weight-shrunk and custom mean variance portfolios are returned as objects of class MeanVar_portfolio. Ones with shrunk weights have a subclass inheriting from it: MV_portfolio_weights_BDOPS21 and GMV_portfolio_weights_BDPS19. 

![Structure of S3 classes for portfolio objects](Scheme_Classes.pdf){}

All mean-variance portfolio objects carry at least eight slots. Slot call contains the function call which created the portfolio object. cov_mtrx and means contain the final estimates of the covariance matrix and the mean vector of the asset returns. inv_cov_mtrx is the inverse of the former. weights is the final estimate of the portfolio weights. Port_Var and Port_mean_return are the expected portfolio variance and portfolio mean return, and, finally Sharpe is the Sharpe ratio computed via the previous two.

For example, in the case of the traditional portfolio, slot weights contains the weights computed according to formula (*), while in the case of a GMV shrinkage portfolio, this slot contains the shrunk weights. In both cases cov_mtrx and means are sample covariance and means. When considering a mean-variance portfolio based on shrunk means and covariance, slots cov_mtrx and means contain the shrinkage estimates.

For MeanVar_portfolio methods summary and plot are available.
```{r, fig.pos = "!H", fig.width=3.8}
portfolio_BDPS19 <- new_MV_portfolio_traditional(x=x, gamma=10)
summary(portfolio_BDPS19)
plot(portfolio_BDPS19)
```


## EU Portfolios with shrunk weights
The main function performing creation of shrinkage portfolios is MVShrinkPortfolio. Essentially, it is a function dispatcher which chooses a method according to arguments type and gamma. 

 | Function |  Type | gamma |
 | --- | --- | --- |
 | new_MV_portfolio_weights_BDOPS21  | shrinkage | < Inf |
 | new_GMV_portfolio_weights_BDPS19  | shrinkage | Inf |
 | new_MV_portfolio_traditional |  traditional | > 0 |
 
It returns either a portfolio in the form of S3 class MeanVar_portfolio or a human-readable error message. Argument type is a switch indicating whether a shrinkage or traditional portfolio is to be returned. MVShrinkPortfolio should be used in interactive programming as it is more user-friendly and slower than underlying methods, while methods themselves should be exploited for writing more complicated but at the same time efficient and fast code.


Weight-shrunk portfolio from [BDOPS21] is constructed by setting type='weights' and gamma being equal to a non-infinite real number. 
```{r}
portfolio_BDOPS21 <- MVShrinkPortfolio(x=x, gamma=gamma, type='shrinkage', b=b, beta = 0.05)
str(portfolio_BDOPS21)
```

The result is the same as that of new_MV_portfolio_weights_BDOPS21 which was eventually dispatched by MVShrinkPortfolio:
```{r, eval=FALSE}
portfolio_BDOPS21 <- new_MV_portfolio_weights_BDOPS21(x=x, gamma=gamma, b=b, beta = 0.05)
```

Global minimum variance portfolios are created by setting gamma=Inf, in which case new_GMV_portfolio_weights_BDPS19	will be dispatched:
```{r}
portfolio_BDPS19 <- MVShrinkPortfolio(x=x, gamma=Inf, type='shrinkage', b=b, beta = 0.05)
str(portfolio_BDPS19)
```

### Confidence intervals of weights ($weight_intervals by Taras & Solomiia) ...


## Custom mean-variance portfolios
It is possible to make custom mean-variance portfolios having pre-specified mean values and a covariance matrix of returns.
HDShOP includes three functions related to this purpose: new_MeanVar_portfolio which is a constructor of objects of class MeanVar_portfolio, validation function for such objects validate_MeanVar_portfolio and helper MeanVar_portfolio. Conventionally, the constructor is a raw creator of objects of the class: it takes arguments mean_vec, cov_mtrx, gamma and computes weights accordingly to the formula *. The validator runs checks designed to verify if the object at hand is a legitimate object of class MeanVar_portfolio, while helper is a combination of the two. Currently, validate_MeanVar_portfolio checks if all the necessary slots are present in the object, its weight and mean vectors have the same length as the number of rows in the covariance matrix and that the covariance matrix is square.

Here is an example of how to use the constructor and the helper.
```{r}
TM <- matrix(0, nrow=p, ncol=p)
diag(TM) <- 1/p

SCM <- Sigma_sample_estimator(x)

Sigma_shr <- CovShrinkBGP14(n=n, TM=TM, SCM=SCM)

means <- mean_bop19(x=x, mu_0=mu_0)

cust_port_BS_LW <- new_MeanVar_portfolio(mean_vec=means$means, 
                                         cov_mtrx=Sigma_shr$S, gamma=2)
summary(cust_port_BS_LW)

cust_port_BS_LW_2 <- MeanVar_portfolio(mean_vec=means$means, 
                                       cov_mtrx=Sigma_shr$S, gamma=2)
summary(cust_port_BS_LW_2)
```

Though, the following ill-designed portfolios created with new_MeanVar_portfolio will be tagged by validate_MeanVar_portfolio:
```{r}
SCM <- matrix(0, nrow=p, ncol=2*p)
diag(SCM) <- 1/p

cust_port_BS_LW_3 <- cust_port_BS_LW_2
cust_port_BS_LW_3$cov_mtrx <- SCM

tools::assertError(
                   validate_MeanVar_portfolio(cust_port_BS_LW_3),
                   classes = "error", verbose = TRUE
                  )
```


## Shrinkage estimators for covariance matrix
The next important function is CovarEstim. This is a dispatcher for functions computing the covariance matrix of the data.
```{r}
Mtrx_naive <- CovarEstim(x, type="trad")
# Mtrx_naive[1:6,1:6]
format(Mtrx_naive[1:3, 1:3], scientific = TRUE, digits = 3)
```

```{r}
Mtrx_bgp <- CovarEstim(x, type="BGP14", TM=TM, SCM=Mtrx_naive)
# Mtrx_bgp[1:6,1:6]
format(Mtrx_bgp[1:3, 1:3], scientific = TRUE, digits = 3)
```


## Shrinkage estimators for mean vectors
```{r}
Mean_BOP <- MeanEstim(x, type="BOP19", mu_0=mu_0)
head(Mean_BOP)
```












